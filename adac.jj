//*****************************************************************
// File:   adac.jj
// Author: Adrian Arribas Mateo 795593 y Ernesto Bielsa Gracia 798799 
// Date:   Marzo 2022
// Coms:   Un tutorial sobre el análisis léxico con javacc
//         https://javacc.github.io/javacc/tutorials/token-manager.html
//*****************************************************************

 options {
   IGNORE_CASE = false;
   COMMON_TOKEN_ACTION = false;
 }

PARSER_BEGIN(adac)
package traductor;
import java.io.IOException;

public class adac {
    public static void main(String[] args) {
    	adac parser;

    	try {
	    	if(args.length == 0) { //entrada desde stdin
				parser = new adac(System.in);
			}
			else { //entrada desde fichero en args[0]
	            parser = new adac(new java.io.FileInputStream(args[0])); 
			}
			parser.programa(); //invoca símbolo inicial de la gramática
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        }
        catch (ParseException e) {
        	System.err.println("Svoid_ERROR: " + e.getMessage());
        }
        catch (Exception e) {
			System.err.println("Finalizo traduccion por deteccion de error no controlado: \n\t" + e.getMessage());
        }
        
    }
}
PARSER_END(adac)

JAVACODE
void error_skipto(int kind) {
  ParseException e = generateParseException();  // generate the exception object
  System.out.println("ERROR SINTACTICO: TOKENS A ELIMINAR");  // print the error message
  Token t;
  // consume tokens all the way up to a token of "kind" - use a do-while loop
  // rather than a while because the current token is the one immediately before
  // the erroneous token (in our case the token immediately before what should
  // have been "if"/"while".
  t = getNextToken();
  while (t.kind != kind){
	  System.out.println("("+t.beginLine+","+t.beginColumn+") Token eliminado: "+t.image);
	   t = getNextToken();
  }
}

TOKEN_MGR_DECLS:
{
  static void showInfo(Token e, String info) {
    System.out.println("("+ e.beginLine + "," + e.beginColumn+ "): "+ info+ " \""+ e.image + "\"");
     }
}
//------------ descripción del AL
SKIP :
{
   " "
|  "\n"
|  "\t"
|  "\r"
|  "\r\n"
}

SPECIAL_TOKEN: {
	< COMMENT: "--"(~["\n"])*"\n" >
}


TOKEN :
{
  	
  	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
| 	< #GBAJO: "_" >
}

TOKEN :
{
 	< tBEGIN: "begin" >
| 	< tINT: "integer" >
| 	< tCHAR: "character" >
| 	< tBOOL: "boolean" >
| 	< tOR: "or" >
|	< tAND: "and" >
| 	< tNOT: "not" >
| 	< tTRUE: "true" >
|	< tFALSE: "false" > 
| 	< tIF: "if" > 
| 	< tRET: "return" > 
| 	< tELSE: "else" > 
| 	< tWHILE: "while" > 
| 	< tSKIPLINE: "skip_line" >
| 	< tDO: "do" > 
| 	< tAP: "(" > 
| 	< tCP: ")" > 
| 	< tAC: "[" > 
| 	< tCC: "]" > 
| 	< tCOMA: "," > 
| 	< tPYC: ";" > 
| 	< tPUTL: "put_line" > 
| 	< tPUT: "put" > 
| 	< tIS: "is" > 
| 	< tTHEN: "then" >   
| 	< tLE: "<=" >
|	< tL: "<" >
|	< tG: ">" >
|	< tGE: ">=" >
|	< tEQ: "=" >
|	< tNEQ: "<>" >
| 	< tDIV: "div" >
|	< tMOD: "mod" >
|	< tPLUS: "+" >
|	< tPROD: "*" >
|	< tMINUS: "-" > 
| 	< tCONST_INT: (< DIGIT >)+ >  
| 	< tOPAS: ":=" >  
| 	< tCONST_STRING: "\"" ("\\" ~[] | ~["\"","\\"] | "\"\"")* "\"" > 
| 	< tVAL: "val" >
|	< tREF: "ref" > 
| 	< tFUNC: "function" > 
| 	< tPROC: "procedure" > 
| 	< tGET: "get" > 
| 	< tEND: "end" > 
| 	< tCONST_CHAR: "'" ("\\" ~[] | ~["\"","\\","\r","\n"] ) "'" >  
| 	< tINT2CHAR: "int2char" > 
| 	< tCHAR2INT: "char2int" > 
| 	< tID:< LETTER >((< GBAJO >)?(< LETTER >|< DIGIT >)+)* > 
}

SPECIAL_TOKEN: {
	< ERROR: (~[]) >
		{
			 System.out.print("ERROR LEXICO: "); showInfo(matchedToken, "simbolo no reconocido:");
			 matchedToken.image = " "; 
		}
}

//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void programa () : 
{

}
{
	( 
		< tPROC >< tID >< tIS > declaracion_variables() declaracion_procs_funcs() bloque_sentencias()
	)
	< EOF >
}

void declaracion_variables () :
{

}
{
	(
	   declaracion() punto_y_coma()
	)*
}

void declaracion () :
{

}
{
	(
	   tipo_variable() lista_vars()
	)
}

void tipo_variable () :
{

}
{
	(
		< tINT > | < tCHAR > | < tBOOL >
	)
}

void lista_vars () :
{

}
{
	(
		variable() ( < tCOMA > variable() )*
	)
}

void variable () :
{

}
{
	(
	  LOOKAHEAD(2)
		(< tID >< tAC > <tCONST_INT >cerrar_corchete()) | < tID > 
	)
}

void declaracion_procs_funcs () :
{

}
{
	(
	  	LOOKAHEAD(2)
		declaracion_proc_func()
	)*
}

void declaracion_funcion () :
{

}
{
	(
		cabecera_funcion() declaracion_variables() bloque_sentencias()
	)
}

void dec_parametros () :
{

}
{
	(	
		clase_parametros() tipo_variable() id_or_array() ( < tCOMA > id_or_array() ) *
	)
}

void id_or_array () :
{

}
{
	( LOOKAHEAD(2)
		(< tID >< tAC > <tCONST_INT >cerrar_corchete()) | < tID > 
	)
}

void instruccion () :
{

}
{
	(
		 inst_leer() punto_y_coma()
		| inst_saltar_linea() punto_y_coma()
		| inst_escribir() punto_y_coma()
		| inst_escribir_linea() punto_y_coma()
		| LOOKAHEAD(2)
			inst_invoc_proc() punto_y_coma()
		| inst_asignacion() punto_y_coma()
		| inst_seleccion() 
		| inst_iteracion()
		| inst_return() punto_y_coma()
	)
}

void inst_asignacion () :
{

}
{
	(
	  asignable() < tOPAS > expresion()
	)
}
/*
void inst_iteracion () :
{

}
{
	( 
		< tWHILE > expresion() < tDO > lista_instrucciones() < tEND > 
	)
}*/

void lista_cero_o_mas_exps () :
{

}
{
	( 
		lista_una_o_mas_exps() 
	)?
}

void expresion () :
{

}
{
	( 
		expresion_simple() (operador_relacional() expresion_simple() )? 
	)
}

void operador_relacional () :
{

}
{
	( 
		< tEQ >|< tL >|< tG >|< tLE >|< tGE >|< tNEQ > 
	)
}

void expresion_simple () :
{

}
{
	( 
		(operador_aditivo())? termino() (operador_aditivo() termino() )*
	)
}

void termino () :
{

}
{
	( 
		factor() ( operador_multiplicativo() factor() ) * 
	)
}

void operador_multiplicativo () :
{

}
{
	( 
		< tPROD >|< tMOD >|< tDIV >|< tAND > | < tOR >
	)
}

void factor () :
{

}
{
	( 
		< tNOT > factor()
		| < tAP > expresion() cerrar_parentesis()
		| < tINT2CHAR > < tAP > expresion() cerrar_parentesis()
		| < tCHAR2INT >	< tAP > expresion() cerrar_parentesis()
		| LOOKAHEAD(2) < tID > < tAP > lista_cero_o_mas_exps() cerrar_parentesis()
		| LOOKAHEAD(2) < tID > < tAC > expresion() cerrar_corchete()
		| < tID >
		| < tCONST_INT >
		| < tCONST_CHAR >
		| < tCONST_STRING >
		| < tTRUE >
		| < tFALSE >
	)
}

//HASTA AQUI LA SEMANTICA

void bloque_sentencias () :
{

}
{
	( 
		< tBEGIN > lista_instrucciones() end()
	)
}

void lista_instrucciones():
{

}
{
	(
		instruccion()
	)*
}

void declaracion_proc_func():
{

}
{
	(
	  	LOOKAHEAD(2)
		declaracion_funcion()
		|declaracion_procedimiento()
		
	)
}

void declaracion_procedimiento():
{

}
{
  	(
  	  cabecera_procedimiento() declaracion_variables() bloque_sentencias()
	)
}

void cabecera_procedimiento():
{

}
{
  	(
  	  < tPROC >< tID > < tAP > (dec_parametros()(< tPYC > dec_parametros())*)? cerrar_parentesis() < tIS >
	)
}

void cabecera_funcion():
{

}//
{
  	(
  	  < tFUNC > tipo_variable() < tID >< tAP > (dec_parametros()(< tPYC > dec_parametros())*)? cerrar_parentesis()< tIS >
	)
}


void clase_parametros():
{

}
{
  	(
  	  < tVAL >|< tREF >
	)
}

void lista_una_o_mas_exps():
{

}
{
  	(
  	  expresion() (< tCOMA > expresion())* 
	)
}

void operador_aditivo():
{

}
{
  	(
  	  < tPLUS > | < tMINUS >
	)
}

void inst_leer() :
{

}
{
	(
		< tGET > < tAP > id_or_array() (< tCOMA > id_or_array())* cerrar_parentesis()
	)
}


void inst_saltar_linea() :
{

}
{
	(
		< tSKIPLINE > < tAP > cerrar_parentesis()
	)
}


void inst_escribir() :
{

}
{
	(
		< tPUT > < tAP > expresion() (< tCOMA > expresion())* cerrar_parentesis()
	)
}


void inst_escribir_linea() :
{

}
{
	(
		< tPUTL > < tAP > (expresion() (< tCOMA > expresion())*)? cerrar_parentesis()
	)
}

void inst_invoc_proc() :
{

}
{
	(
		< tID > < tAP > lista_cero_o_mas_exps() cerrar_parentesis()
	)
}


void asignable () :
{

}
{
	(
	  LOOKAHEAD(2) < tID > < tAC > expresion() cerrar_corchete()
	| < tID > 
	)
}

void inst_seleccion():
{

}
{
	(
	 	< tIF > expresion() < tTHEN > lista_instrucciones() (< tELSE > lista_instrucciones())? end()
	)
}


void inst_iteracion():
{

}
{
	(
	 	< tWHILE > expresion() < tDO > lista_instrucciones() end()
	)
}

void inst_return():
{

}
{
	(
	 	< tRET > expresion()
	)
}

void punto_y_coma():{
	
}
{
	(
		< tPYC >
		| error_skipto(tPYC)
	)
}

void end():{
	
}
{
	(
		< tEND >
		| error_skipto(tEND)
	)
}

void cerrar_corchete():{

}
{
	(
		< tCC >
		| error_skipto(tCC)
	)
}

void cerrar_parentesis():{

}
{
	(
		< tCP >
		| error_skipto(tCP)
	)
}
