//*****************************************************************
// File:   adac.jj
// Author: Adrian Arribas Mateo 795593 y Ernesto Bielsa Gracia 798799 
// Date:   Marzo 2022
// Coms:   Un tutorial sobre el análisis léxico con javacc
//         https://javacc.github.io/javacc/tutorials/token-manager.html
//*****************************************************************

 options {
   IGNORE_CASE = false;
   COMMON_TOKEN_ACTION = false;
 }

PARSER_BEGIN(adac)
package traductor;

public class adac {
    public static void main(String[] args) {
    	adac parser;

    	try {
	    	if(args.length == 0) { //entrada desde stdin
				parser = new adac(System.in);
			}
			else { //entrada desde fichero en args[0]
	            parser = new adac(new java.io.FileInputStream(args[0])); 
			}
			parser.programa(); //invoca símbolo inicial de la gramática
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        }
        catch (ParseException e) {
        	System.err.println("SINT_ERROR: " + e.getMessage());
        } 
    }
}
PARSER_END(adac)
TOKEN_MGR_DECLS:
{
  static void showInfo(Token e, String info) {
    System.out.println("("+ e.beginLine + "," + e.beginColumn+ "): "+ info+ " \""+ e.image + "\"");
     }
}
//------------ descripción del AL
SKIP :
{
   " "
|  "\n"
|  "\t"
|  "\r"
|  "\r\n"
}

SPECIAL_TOKEN: {
	< COMMENT: "--"(~["\n"])*"\n" >
}


TOKEN :
{
  	
  	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
| 	< #GBAJO: "_" >
}

TOKEN :
{
 	< tBEGIN: "begin" >
 		{
 			//mostrar la información pedida
			showInfo(matchedToken, "palabra reservada");
		}
| 	< tINT: "integer" >
| 	< tCHAR: "character" >
| 	< tBOOL: "boolean" >
| 	< tOR: "or" >
|	< tAND: "and" >
| 	< tNOT: "not" >
| 	< tTRUE: "true" >
|	< tFALSE: "false" > { showInfo(matchedToken, "valor booleano");}
| 	< tIF: "if" > { showInfo(matchedToken, "operador if");}
| 	< tRET: "return" > { showInfo(matchedToken, "operador return");}
| 	< tELSE: "else" > { showInfo(matchedToken, "operador else");}
| 	< tWHILE: "while" > { showInfo(matchedToken, "operador while");}
| 	< tSKIPLINE: "skip_line" >
| 	< tDO: "do" > { showInfo(matchedToken, "operador do");}
| 	< tAP: "(" > { showInfo(matchedToken, "abrir parentesis");}
| 	< tCP: ")" > { showInfo(matchedToken, "cerrar parentesis");}
| 	< tAC: "[" > { showInfo(matchedToken, "abrir corchete");}
| 	< tCC: "]" > { showInfo(matchedToken, "cerrar corchete");}
| 	< tCOMA: "," > { showInfo(matchedToken, "coma");}
| 	< tPYC: ";" > { showInfo(matchedToken, "punto y coma");}
| 	< tPUTL: "put_line" > { showInfo(matchedToken, "operador put_line");}
| 	< tPUT: "put" > { showInfo(matchedToken, "operador put");}
| 	< tIS: "is" > { showInfo(matchedToken, "operador is"); }
| 	< tTHEN: "then" > { showInfo(matchedToken, "operador then"); }  
| 	< tLE: "<=" >
|	< tL: "<" >
|	< tG: ">" >
|	< tGE: ">=" >
|	< tEQ: "=" >
|	< tNEQ: "<>" >{ showInfo(matchedToken, "operador comparacion");}
| 	< tDIV: "div" >
|	< tMOD: "mod" >
|	< tPLUS: "+" >
|	< tPROD: "*" >
|	< tMINUS: "-" > { showInfo(matchedToken, "operador");}
| 	< tCONST_INT: (< DIGIT >)+ >  { showInfo(matchedToken, "constante entera");}
| 	< tOPAS: ":=" >  { showInfo(matchedToken, "operador asignacion");}
| 	< tCONST_STRING: "\"" ("\\" ~[] | ~["\"","\\"] | "\"\"")* "\"" > { showInfo(matchedToken, "constante string");}
| 	< tVAL: "val" >
|	< tREF: "ref" > { showInfo(matchedToken, "paso de parametro");}
| 	< tFUNC: "function" > { showInfo(matchedToken, "palabra reservada");}
| 	< tPROC: "procedure" > { showInfo(matchedToken, "palabra reservada");}
| 	< tGET: "get" > { showInfo(matchedToken, "palabra reservada");}
| 	< tEND: "end" > { showInfo(matchedToken, "palabra reservada"); }
| 	< tCONST_CHAR: "'" ("\\" ~[] | ~["\"","\\","\r","\n"] ) "'" >  { showInfo(matchedToken, "caracter simple");}
| 	< tINT2CHAR: "int2char" > { showInfo(matchedToken, "palabra reservada"); }
| 	< tCHAR2INT: "char2int" > { showInfo(matchedToken, "palabra reservada"); }
| 	< tID:< LETTER >((< GBAJO >)?(< LETTER >|< DIGIT >)+)* > { showInfo(matchedToken, "identificador");}
}

SPECIAL_TOKEN: {
	< ERROR: (~[]) >
		{
			 System.out.print("ERROR LEXICO: "); showInfo(matchedToken, "simbolo no reconocido:"); 
		}
}

//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void programa () : 
{

}
{
	( 
		< tPROC >< tID >< tIS > declaracion_variables() declaracion_procs_funcs() /*bloque_sentencias()*/
	)+
	//< EOF >
}

void declaracion_variables () :
{

}
{
	(	   declaracion() < tPYC >
	)*
}

void declaracion () :
{

}
{
	(
	   tipo_variable() lista_vars()
	)
}

void tipo_variable () :
{

}
{
	(
		< tINT > | < tCHAR > | < tBOOL >
	)
}

void lista_vars () :
{

}
{
	(
		variable() ( < tCOMA > variable() )*
	)
}

void variable () :
{

}
{
	(
	  LOOKAHEAD(2)
		(< tID >< tAC > <tCONST_INT >< tCC >) | < tID > 
	)
}

void declaracion_procs_funcs () :
{

}
{
	(
	  	LOOKAHEAD(2)
		declaracion_proc_func()
	)*
}

void declaracion_funcion () :
{

}
{
	(
		cabecera_funcion() declaracion_variables() bloque_sentencias()
	)
}

void dec_parametros () :
{

}
{
	(	
		clase_parametros() tipo_variable() id_or_array() ( < tPYC > id_or_array() ) *
	)
}

void id_or_array () :
{

}
{
	( LOOKAHEAD(2)
		(< tID >< tAC > <tCONST_INT >< tCC >) | < tID > 
	)
}

void instruccion () :
{

}
{
	(
		 inst_leer() < tPYC >
		| inst_saltar_linea() < tPYC >
		| inst_escribir() < tPYC >
		| inst_escribir_linea() < tPYC >
		| LOOKAHEAD(2)
			inst_invoc_proc() < tPYC >
		| inst_asignacion() < tPYC >
		| inst_seleccion() 
		| inst_iteracion()
		| inst_return() < tPYC >
	)
}

void inst_asignacion () :
{

}
{
	(
	  asignable() < tOPAS > expresion()
	)
}
/*
void inst_iteracion () :
{

}
{
	( 
		< tWHILE > expresion() < tDO > lista_instrucciones() < tEND > 
	)
}*/

void lista_cero_o_mas_exps () :
{

}
{
	( 
		lista_una_o_mas_exps() 
	)?
}

void expresion () :
{

}
{
	( 
		expresion_simple() (operador_relacional() expresion_simple() )? 
	)
}

void operador_relacional () :
{

}
{
	( 
		< tEQ >|< tL >|< tG >|< tLE >|< tGE >|< tNEQ > 
	)
}

void expresion_simple () :
{

}
{
	( 
		(operador_aditivo())? termino() (operador_aditivo() termino() )*
	)
}

void termino () :
{

}
{
	( 
		factor() ( operador_multiplicativo() factor() ) * 
	)
}

void operador_multiplicativo () :
{

}
{
	( 
		< tPROD >|< tMOD >|< tDIV >|< tAND > 
	)
}

void factor () :
{

}
{
	( 
		< tNOT > factor()
		| < tAP > expresion() < tCP >
		| < tINT2CHAR > < tAP > expresion() < tCP >
		| < tCHAR2INT >	< tAP > expresion() < tCP >
		| LOOKAHEAD(2) < tID > < tAP > lista_cero_o_mas_exps() < tCP >
		| LOOKAHEAD(2) < tID > < tAC > expresion() < tCC >
		| < tID >
		| < tCONST_INT >
		| < tCONST_CHAR >
		| < tCONST_STRING >
		| < tTRUE >
		| < tFALSE >
	)
}

//HASTA AQUI LA SEMANTICA

void bloque_sentencias () :
{

}
{
	( 
		< tBEGIN > lista_instrucciones() < tEND >
	)
}

void lista_instrucciones():
{

}
{
	(
		instruccion()
	)*
}

void declaracion_proc_func():
{

}
{
	(
	  	LOOKAHEAD(2)
		declaracion_funcion()
		|declaracion_procedimiento()
		
	)
}

void declaracion_procedimiento():
{

}
{
  	(  	  cabecera_procedimiento() declaracion_variables() bloque_sentencias()
	)
}

void cabecera_procedimiento():
{

}
{
  	(
  	  < tPROC >< tID > < tAP > (dec_parametros()(< tCOMA > dec_parametros())*)? < tCP > < tIS >
	)
}

void cabecera_funcion():
{

}
{
  	(
  	  < tFUNC > tipo_variable() < tID >< tAP > (dec_parametros()(< tCOMA > dec_parametros())*)? < tCP >< tIS >
	)
}


void clase_parametros():
{

}
{
  	(
  	  < tVAL >|< tREF >
	)
}

void lista_una_o_mas_exps():
{

}
{
  	(
  	  expresion() (< tCOMA > expresion())* 
	)
}

void operador_aditivo():
{

}
{
  	(
  	  < tPLUS > | < tMINUS >
	)
}

void inst_leer() :
{

}
{
	(
		< tGET > < tAP > id_or_array() (< tCOMA > id_or_array())* < tCP >
	)
}


void inst_saltar_linea() :
{

}
{
	(
		< tSKIPLINE > < tAP > < tCP >
	)
}


void inst_escribir() :
{

}
{
	(
		< tPUT > < tAP > expresion() (< tCOMA > expresion())* < tCP >
	)
}


void inst_escribir_linea() :
{

}
{
	(
		< tPUTL > < tAP > (expresion() (< tCOMA > expresion())*)? < tCP >
	)
}

void inst_invoc_proc() :
{

}
{
	(
		< tID > < tAP > lista_cero_o_mas_exps() < tCP >
	)
}


void asignable () :
{

}
{
	(
	  LOOKAHEAD(2) < tID > < tAC > expresion() < tCC >
	| < tID > 
	)
}

void inst_seleccion():
{

}
{
	(
	 	< tIF > expresion() < tTHEN > lista_instrucciones() (< tELSE > lista_instrucciones())? < tEND >
	)
}


void inst_iteracion():
{

}
{
	(
	 	< tWHILE > expresion() < tDO > lista_instrucciones() < tEND >
	)
}

void inst_return():
{

}
{
	(
	 	< tRET > expresion()
	)
}
