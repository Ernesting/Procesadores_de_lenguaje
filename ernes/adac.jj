//*****************************************************************
// File:   adac.jj
// Author: ...........
// Date:   ...........
// Coms:   Un tutorial sobre el análisis léxico con javacc
//         https://javacc.github.io/javacc/tutorials/token-manager.html
//*****************************************************************

 options {
   IGNORE_CASE = false;
   COMMON_TOKEN_ACTION = false;
 }

PARSER_BEGIN(adac)
package traductor;

public class adac {
    public static void main(String[] args) {
    	adac parser;

    	try {
	    	if(args.length == 0) { //entrada desde stdin
				parser = new adac(System.in);
			}
			else { //entrada desde fichero en args[0]
	            parser = new adac(new java.io.FileInputStream(args[0])); 
			}
			parser.S(); //invoca símbolo inicial de la gramática
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        }
        catch (ParseException e) {
        	System.err.println("SINT_ERROR: " + e.getMessage());
        } 
    }
}
PARSER_END(adac)
TOKEN_MGR_DECLS:
{
  static void showInfo(Token e, String info) {
    System.out.println("("+ e.beginLine + "," + e.beginColumn+ "): "+ info+ " \""+ e.image + "\"");
     }
}
//------------ descripción del AL
SKIP :
{
   " "
|  "\n"
|  "\t"
|  "\r"
}

TOKEN :
{
  	
  	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
| 	< #GBAJO: "_" >
//|   < #PYC: ";" >
| 	< #TRUE: "true" >
|   < #FALSE: "false" >
| 	< #INT: "integer" >
| 	< #CHAR: "character" >
| 	< #BOOL: "boolean" >
//| 	< #WHILE: "while" >
| 	< #ARRAY: "["(< DIGIT >)+"]" >
//| 	< #PROC: "procedure" >
//| 	< #FUNC: "function" >
| 	< #VAL: "val" >
| 	< #REF: "ref" >
| 	< #varINT2: < INT >" "< ID >(< ARRAY >)?(", "< ID >(< ARRAY >)?)* >
| 	< #varCHAR2: < CHAR >" "< ID >(< ARRAY >)?(", "< ID >(< ARRAY >)?)* >
| 	< #varBOOL2: < BOOL >" "< ID >(< ARRAY >)?(", "< ID >(< ARRAY >)?)* >
//| 	< #TYPE: (< INT >|< CHAR >|< BOOL >) >
|   < #PRUEBA: < IF >>
| 	< plus: "+" > { showInfo(matchedToken, "operador suma");}
}

TOKEN :
{
 	< tBEGIN: "begin" >
 		{
 			//mostrar la información pedida
			showInfo(matchedToken, "palabra reservada");
		}
| 	< SPACE: (" ")* >
| 	< OP : "div"|"mod"|"+"|"*"|"-" > { showInfo(matchedToken, "operador");}
| 	< OR: "or" >
| 	< AND: "and" >
| 	< TF: < TRUE >|< FALSE > > { showInfo(matchedToken, "valor booleano");}
| 	< IF: "if" > { showInfo(matchedToken, "operador if");}
| 	< RET: "return" > { showInfo(matchedToken, "operador return");}
| 	< ELSE: "else" > { showInfo(matchedToken, "operador else");}
| 	< WHILE: "while" > { showInfo(matchedToken, "operador while");}
| 	< DO: "do" > { showInfo(matchedToken, "operador do");}
| 	< AP: "(" > { showInfo(matchedToken, "abrir parentesis");}
| 	< CP: ")" > { showInfo(matchedToken, "cerrar parentesis");}
| 	< COMA: "," > { showInfo(matchedToken, "coma");}
| 	< PYC: ";" > { showInfo(matchedToken, "punto y coma");}
| 	< PUTL: "put_line" > { showInfo(matchedToken, "operador put_line");}
| 	< PUT: "put" > { showInfo(matchedToken, "operador put");}
| 	< IS: "is" > { showInfo(matchedToken, "operador is"); }
| 	< THEN: "then" > { showInfo(matchedToken, "operador then"); }  
| 	< CMP: ("<="|"<"|">"|">="|"="|"<>") >{ showInfo(matchedToken, "comparador");}
| 	< COMMENT: "--"(~["\n"])*"\n" > { showInfo(matchedToken, "comment"); } 
| 	< NUMBER: ["1"-"9"](< DIGIT >)*|"0" >  { showInfo(matchedToken, "constante entera");}
//| 	< EXPR: (< NUMBER >|< ID >) >
| 	< OPAS: ":=" >  { showInfo(matchedToken, "operador asignacion");}
| 	< STRING: "\"" ("\\" ~[] | ~["\"","\\"] )* "\"" > { showInfo(matchedToken, "constante string");}
| 	< TYPE: (< INT >|< CHAR >|< BOOL >) > { showInfo(matchedToken, "tipo de dato");}
| 	< tARRAY: < ARRAY > >

| 	< PTYPE: (< VAL >|< REF >) > { showInfo(matchedToken, "paso de parametro");}
| 	< FUNC: "function" > { showInfo(matchedToken, "palabra reservada");}
| 	< PROC: "procedure" > { showInfo(matchedToken, "palabra reservada");}
| 	< GET: "get" > { showInfo(matchedToken, "palabra reservada");}
| 	< END: "end" > { showInfo(matchedToken, "palabra reservada"); }
|	< FUNCTION: < ID >< SPACE >< AP >< SPACE >((< ID >|< NUMBER >)< SPACE >(< COMA ><SPACE >(< ID >|< NUMBER >))*)?< SPACE >< CP > > { showInfo(matchedToken, "funcion");}
| 	< COND2: < AP ><SPACE >< COND >< SPACE >(< SPACE >(< OR >|< AND >)< SPACE >< AP ><SPACE >< COND >< SPACE >< CP >)*< SPACE >< CP >(< SPACE >(< OR >|< AND >)< SPACE >< AP ><SPACE >< COND >< SPACE >< CP >)*|< COND > >
| 	< COND: (< NUMBER >|< ID >|< FUNCTION >)(< SPACE >< CMP >< SPACE >(< NUMBER >|< ID >|< FUNCTION >))*| < AP >< SPACE >(< NUMBER >|< ID >|< FUNCTION >)(< SPACE >< CMP >< SPACE >(< NUMBER >|< ID >|< FUNCTION >)< SPACE >)*< CP > >
//| 	< EXPR: (< NUMBER >|< ID >|< FUNCTION >)>
| 	< EXPR1: (< ID >|< NUMBER >|< FUNCTION >)(< SPACE >< OP >< SPACE >(< ID >|< NUMBER >|< FUNCTION >))* > 
| 	< EXPR2: < AP > (< ID >|< NUMBER >|< FUNCTION >)< SPACE >< OP >< SPACE >(< ID >|< NUMBER >|< FUNCTION >)(< SPACE >< OP >< SPACE >(< ID >|< NUMBER >|< FUNCTION >))*< CP > > 
| 	< char2: "'" ("\\" ~[] | ~["\"","\\"] ) "'" >
| 	< int2char: "int2char"< SPACE >< AP >< NUMBER >< CP > >
| 	< char2int: "char2int"< SPACE >< AP >< char2 >< CP > >


| 	< ID:< LETTER >((< GBAJO >)?(< LETTER >|< DIGIT >)+)* > { showInfo(matchedToken, "identificador");}
//| 	< ASIG: < ID >" "< OPAS >" "(< ID >| < EXPR >)< PYC > >
///|	< EXPR1: ((< ID >(< tARRAY >)?)|(< NUMBER >)|(< ID >< AP >((< ID >(< tARRAY >)?|< NUMBER >)(< COMA >|(< ID >(< tARRAY >)?|< NUMBER >))*)?< CP >)) > 
///|	< EXPR: (< AP >< EXPR1 ><CP >)|< EXPR1 > > { showInfo(matchedToken, "expresion");}

//|	< TERMINO: (< ID >|< NUMBER >|< FUNCTION >)(< plus >(< ID >|< NUMBER >|< FUNCTION >))* >
//| 	< EXPR: < TERMINO >< EXPR2 > >
//| 	< EXPR2: (< plus >< TERMINO >)* >
//|	< COND: (< ID >|< NUMBER >)" "(< CMP >)" "(< ID >|< NUMBER >) >
}
//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void S () : 
{

}
{
	( 
		< tBEGIN >
		| < COMMENT > 
		| < TYPE >< ID >(< tARRAY >)?(< COMA >< ID >(< tARRAY >)?)*< PYC >
		| < WHILE >< COND2 >< DO >
		| < STRING >
		| < RET >(< ID >|< NUMBER >|< TF >)< PYC >
		| < END >
		| < IF >< COND2 >< THEN >
		| < ID >< OPAS >(< NUMBER >|< ID >|< FUNCTION >|<EXPR1 >)< PYC >
		| < ELSE >
		| < PROC >< ID >(< AP >< PTYPE >< TYPE >< ID >(< tARRAY >)?(< COMA >< ID >(< tARRAY >)?)*(< PYC >< PTYPE >< TYPE >< ID >(< tARRAY >)?(< COMA >< ID >(< tARRAY >)?)*)*< CP >)?< IS >
		| < FUNC >< TYPE >< ID >< AP >(< PTYPE >< TYPE >< ID >(< tARRAY >)?(< COMA >< ID >(< tARRAY >)?)*(< PYC >< PTYPE >< TYPE >< ID >(< tARRAY >)?(< COMA >< ID >(< tARRAY >)?)*)*)?< CP >< IS >
		| (< PUTL >|< PUT >)< AP >(< STRING >|< ID >|< int2char >|< char2int >)(< COMA >(< STRING >|< ID >|< int2char >|< char2int >))*< CP >< PYC > 
		| < GET >< AP >< ID >(< tARRAY >)?< CP >< PYC >
		
	)+
	< EOF >
}
