//*****************************************************************
// File:   adac.jj
// Author: Adrian Arribas Mateo y Ernesto Bielsa Gracia 798799 
// Date:   Marzo 2022
// Coms:   Un tutorial sobre el análisis léxico con javacc
//         https://javacc.github.io/javacc/tutorials/token-manager.html
//*****************************************************************

 options {
   IGNORE_CASE = false;
   COMMON_TOKEN_ACTION = false;
 }

PARSER_BEGIN(adac)
package traductor;

public class adac {
    public static void main(String[] args) {
    	adac parser;

    	try {
	    	if(args.length == 0) { //entrada desde stdin
				parser = new adac(System.in);
			}
			else { //entrada desde fichero en args[0]
	            parser = new adac(new java.io.FileInputStream(args[0])); 
			}
			parser.S(); //invoca símbolo inicial de la gramática
		}
		catch (java.io.FileNotFoundException e) {
			System.err.println ("Fichero " + args[0] + " no encontrado.");
		}
		catch (TokenMgrError e) {
        	System.err.println("LEX_ERROR: " + e.getMessage());
        }
        catch (ParseException e) {
        	System.err.println("SINT_ERROR: " + e.getMessage());
        } 
    }
}
PARSER_END(adac)
TOKEN_MGR_DECLS:
{
  static void showInfo(Token e, String info) {
    System.out.println("("+ e.beginLine + "," + e.beginColumn+ "): "+ info+ " \""+ e.image + "\"");
     }
}
//------------ descripción del AL
SKIP :
{
   " "
|  "\n"
|  "\t"
|  "\r"
}

TOKEN :
{
  	
  	< #LETTER: (["a"-"z","A"-"Z"]) >
|	< #DIGIT: ["0"-"9"] >
| 	< #GBAJO: "_" >
| 	< #INT: "integer" >
| 	< #CHAR: "character" >
| 	< #BOOL: "boolean" >
}

TOKEN :
{
 	< tBEGIN: "begin" >
 		{
 			//mostrar la información pedida
			showInfo(matchedToken, "palabra reservada");
		}
| 	< tOP : "div"|"mod"|"+"|"*"|"-" > { showInfo(matchedToken, "operador");}
| 	< tBOP: "or"|"and" >
| 	< TF: "true"|"false" > { showInfo(matchedToken, "valor booleano");}
| 	< tIF: "if" > { showInfo(matchedToken, "operador if");}
| 	< tRET: "return" > { showInfo(matchedToken, "operador return");}
| 	< tELSE: "else" > { showInfo(matchedToken, "operador else");}
| 	< tWHILE: "while" > { showInfo(matchedToken, "operador while");}
| 	< tDO: "do" > { showInfo(matchedToken, "operador do");}
| 	< tAP: "(" > { showInfo(matchedToken, "abrir parentesis");}
| 	< tCP: ")" > { showInfo(matchedToken, "cerrar parentesis");}
| 	< tAC: "[" > { showInfo(matchedToken, "abrir corchete");}
| 	< tCC: "]" > { showInfo(matchedToken, "cerrar corchete");}
| 	< tCOMA: "," > { showInfo(matchedToken, "coma");}
| 	< tPYC: ";" > { showInfo(matchedToken, "punto y coma");}
| 	< tPUTL: "put_line" > { showInfo(matchedToken, "operador put_line");}
| 	< tPUT: "put" > { showInfo(matchedToken, "operador put");}
| 	< tIS: "is" > { showInfo(matchedToken, "operador is"); }
| 	< tTHEN: "then" > { showInfo(matchedToken, "operador then"); }  
| 	< tCMP: ("<="|"<"|">"|">="|"="|"<>") >{ showInfo(matchedToken, "operador comparacion");}
| 	< tCOMMENT: "--"(~["\n","\r"])*"\n" > { showInfo(matchedToken, "comment"); } 
| 	< tNUMBER: (< DIGIT >)+ >  { showInfo(matchedToken, "constante entera");}
| 	< tOPAS: ":=" >  { showInfo(matchedToken, "operador asignacion");}
| 	< tSTRING: "\"" ("\\" ~[] | ~["\"","\\"] )* "\"" > { showInfo(matchedToken, "constante string");}
| 	< tTYPE: (< INT >|< CHAR >|< BOOL >) > { showInfo(matchedToken, "tipo de dato");}
| 	< tPTYPE: "val"|"ref" > { showInfo(matchedToken, "paso de parametro");}
| 	< tFUNC: "function" > { showInfo(matchedToken, "palabra reservada");}
| 	< tPROC: "procedure" > { showInfo(matchedToken, "palabra reservada");}
| 	< tGET: "get" > { showInfo(matchedToken, "palabra reservada");}
| 	< tDATO: "dato" > { showInfo(matchedToken, "palabra reservada");}
| 	< tEND: "end" > { showInfo(matchedToken, "palabra reservada"); }
| 	< tSCHAR: "'" ("\\" ~[] | ~["\"","\\","\r","\n"] ) "'" >  { showInfo(matchedToken, "caracter simple");}
| 	< tI2C: "int2char" > { showInfo(matchedToken, "palabra reservada"); }
| 	< tC2I: "char2int" > { showInfo(matchedToken, "palabra reservada"); }
| 	< ID:< LETTER >((< GBAJO >)?(< LETTER >|< DIGIT >)+)* > { showInfo(matchedToken, "identificador");}
| 	< ERROR: (~["\n","\r"])+"\n" > { System.out.print("ERROR LEXICO: "); showInfo(matchedToken, "simbolo no reconocido:"); }
}
//------------ Símbolo inicial de la gramática. Para análisis léxico no hace falta más
void S () : 
{

}
{
	( 
		< tBEGIN >
		|< tOP >| < tBOP >| < TF >|< tIF >|< tRET >|< tELSE >|< tWHILE >|< tDO >
		|< tAP >|< tCP >|< tAC >|< tCC >|< tCOMA >|< tPYC >|< tPUTL >|< tPUT >
		|< tIS >|< tTHEN >|< tCMP >|< tCOMMENT >|< tNUMBER >|< tOPAS >|< tSTRING >
		|< tTYPE >|< tPTYPE >|< tFUNC >|< tPROC >|< tGET >|< tDATO >|< tEND >
		|< tSCHAR >|< tI2C >|< tC2I >|< ID >|< ERROR >
	)+
	< EOF >
}
